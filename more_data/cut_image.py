import numpy as np
import cv2
import os

# FUNCTION DEFINITIONS

def get_y_values(image_path):
    '''
    Takes in an image, undergoes preprocessing to make contours between numbers more clear, 
    identifies contours, and returns y-values of those contours. I am going to descriibe more 
    specific preprocessing steps line by line because it makes more sense that way. 
    '''
    # Load the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # PROCESSING THE IMAGE
   
    # Binary thresholding
    _, binary_image = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
    binary_inverted = cv2.bitwise_not(binary_image)

    # Define a kernel to be used for dilation. x and y coordinate parameters
    # are used to specify extent of the dilation. 
    kernel = np.ones((1,16), np.uint8)

    # Dilation attempts to fill in the gaps between black areas of the image.
    # This gives us an image of rough black rectangles where the numbers were. 
    filled_image = cv2.dilate(binary_inverted, kernel, iterations=2)

    # Reduce matrix to a n row x 1 columns matrix and invert the pixels. 
    reducedImage = cv2.reduce(filled_image, 1, cv2.REDUCE_MAX)
    reducedImage = 255 - reducedImage

    # FINDING THE CONTOURS

    # Find the contours on the image. RETR_CCOMP gives inner and outer contours but we
    # only want the outside ones saved in the first entry. CHAIN_APPROX_SIMPLE reduces the size
    # of the contour data by only saving endpoints and assuming a straight line between them. 
    contours, _ = cv2.findContours(reducedImage, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)

    # Intialize lists to store the poly approximation and bound
    contoursPoly = [None] * len(contours)
    separatingLines = [ ]

    imageWidth = image.shape[1]

   
    for c in contours:

        # Approximate the contour to a polygon
        contoursPoly = cv2.approxPolyDP(c, 3, True)

        # Convert the polygon to a bounding rectangle
        boundRect = cv2.boundingRect(contoursPoly)

        # Get the bounding rects data:
        [x,y,w,h] = boundRect

        # Calculate line middle (vertical) coordinate,
        # Start point and end point:
        lineCenter = y + (0.5 * h)
        startPoint = (0,int(lineCenter))
        endPoint =  (int(imageWidth),int(lineCenter))

        # Store start and end points in list:
        separatingLines.append((startPoint, endPoint))


    return [i[0][1] for i in separatingLines]


def chop_image(image_path, output_dir, y_values):
    '''
    This function takes in the y-values generated by get_y_values() and chops the image along those lines. Then it saves
    them in the output_dir directory. 
    '''

    # Global variable for maintaining file count when writing. 
    global file_count
   
    # Read the input image
    image = cv2.imread(image_path)
    height, width, _ = image.shape
    
    # Iterate through the y-values and chop the image
    for i, y in enumerate(y_values):
        if i == 0:
            chopped_image = image[:y, :, :]
        else:
            prev_y = y_values[i - 1]
            chopped_image = image[prev_y:y, :, :]
        
        # Save new chopped image to directory
        output_file = os.path.join(output_dir, f"chopped_{file_count}.png")
        file_count += 1
        cv2.imwrite(output_file, chopped_image)

def cleanup_directory(directory, min_size_bytes):
    '''
    This function iterates through the output directory and removes files that are below
    a certain size specified in the parameter.
    '''
    
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        
        if os.path.isfile(file_path):
            file_size_bytes = os.path.getsize(file_path)
           
            if file_size_bytes < min_size_bytes:
                os.remove(file_path)
               

def main():

    # This is set up so that your current working directory is the code folder
    current_dir = os.path.dirname(os.path.abspath(__file__))
    folder_path = os.path.join(current_dir, 'uncut_images')
    output_file_path = os.path.join(current_dir, 'cut_images')
    
    # Here we collect the filenames from the folder and sort them by image number.
    filenames = os.listdir(folder_path)

    # Now we loop through our filenames and run the functions
    for filename in filenames:

        image_path = os.path.join(folder_path, filename)
        y_values = get_y_values(image_path)
        y_values.reverse()
    
        chop_image(image_path, output_file_path, y_values)


    # Method misidentifies some whitespaces as their own entry so we remove
    # files below a certain size to clean things up
    min_size = 1024 # bytes
    cleanup_directory(output_file_path, min_size)

    print('done')





if __name__ == '__main__':

    # GLOBAL VARIABLE
    file_count = 0

    main()
    